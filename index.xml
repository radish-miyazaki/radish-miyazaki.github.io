<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>method_missing(*)</title>
    <link>https://radish-miyazaki.github.io/</link>
    <description>Recent content on method_missing(*)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <copyright>2022 Radish All rights reserved</copyright>
    <lastBuildDate>Wed, 14 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://radish-miyazaki.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How to accept multiple args in the make command</title>
      <link>https://radish-miyazaki.github.io/9/</link>
      <pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://radish-miyazaki.github.io/9/</guid>
      <description>概要 makeコマンドで複数引数を取れるようにする方法があったので記録する。 Dockerコマンドを集約するときに使うと便利。
結論 makeコマンドが受け取った、2番目の引数以降の値をすべて対象のコマンドに渡せばOK。
hogehoge: &amp;lt;引数を渡したいコマンド&amp;gt; $(wordlist 2, $(words $(MAKECMDGOALS) - 2), $(MAKECMDGOALS)) 解説 wordlist Makefileの組み込み関数の一種。 第3引数で指定した値から、第1引数~第2引数の位置の文字列を抽出する。
hoge: @echo $(wordlist 1, 2, &amp;#34;hoge fuga hoge&amp;#34;) # hoge fuga words 文字列数を返す。</description>
    </item>
    
    <item>
      <title>How to solve when &#39;ALTER TABLE&#39; does not work in sqlx</title>
      <link>https://radish-miyazaki.github.io/8/</link>
      <pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://radish-miyazaki.github.io/8/</guid>
      <description>概要 Rustでsqlxを使っていた際に、下記のコードだと./migrationsディレクトリに存在するALTER TABLEを用いたSQLファイルが実行されなかったが、なんとか動作するようにはなったので、備忘録としてとどめておく。
ちなみにsqlx migrate runコマンドだと動作した。
sqlx::migrate!() .run(&amp;amp;pool) .await .expect(&amp;#34;Cannot run migration&amp;#34;); ALTER TABLE questions ADD COLUMN account_id SERIAL;  開発環境  PostgreSQL: 13 Rust: 1.62   回避策 migrate!マクロの引数に、migrationsディレクトリのパスを指定すると動作するようになった。</description>
    </item>
    
    <item>
      <title>Transition Heroku Redis from Hobby_Dev to Premium on ROR</title>
      <link>https://radish-miyazaki.github.io/7/</link>
      <pubDate>Tue, 30 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://radish-miyazaki.github.io/7/</guid>
      <description>概要 Heroku Dyno, PostgreSQL, Redisの無料プランが10月末日から廃止になるので、開発環境のRedisを有料プランに移行した。
その際に少々ハマってしまったので、まとめておく。
 開発環境  Rails: 6.1.1.4 Ruby: 2.7.5 Redis: 6.2.3   Hobby_Dev と Premiumの違い Hobby_DevではTLSの有無に関わらず接続が可能だが、PremiumでかつRedisのバージョンが6の場合は、TLS接続が必須となっている。
ただし、Heroku側で設定は自動で行ってくれているので、クライアント側ではSSLでの接続をオフにするように設定を追加するだけで良い。
 サーバ（Heroku）での対応 DashboardのAddons管理ページ（&amp;lt;アプリケーションのダッシュボード&amp;gt;/resources）から簡単にできるので省略。
 クライアント（Rails）での対応 Redisインスタンスの初期設定 config/initializersディレクトリ直下に、redis.rbファイルを作成し、Redisインスタンスの設定を追加。
if Rails.</description>
    </item>
    
    <item>
      <title>Array vs Slice vs Vector</title>
      <link>https://radish-miyazaki.github.io/6/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://radish-miyazaki.github.io/6/</guid>
      <description>概要 以前Rustを学習していたが、業務で新しい言語を学ぶ必要が出てきたので、一時中断していた。
最近Rustに入門し直したので、その時に出てきた配列とスライスとベクタの違いを備忘録として書き留める。
 配列 ([T; n]) 配列は固定長で、同一型を格納するリストである。
配列内の要素を入れ替えることはできるが、サイズは変更できない。
fn main() { let mut arr = [3, 5, 1, 2, 4]; arr.sort(); println!(&amp;#34;{:?}&amp;#34;, arr) // [1, 2, 3, 4, 5]  // Error: method not found in `[{integer}; 5]`  arr.</description>
    </item>
    
    <item>
      <title>Variance and TypeScript</title>
      <link>https://radish-miyazaki.github.io/5/</link>
      <pubDate>Thu, 17 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://radish-miyazaki.github.io/5/</guid>
      <description>概要 型について理解を深める上で必要不可欠となる変性（Variance）をTypescriptを通して学んだので、まとめておく。
 サブタイプとスーパータイプ まずは変性について学ぶ上で、知っておくべき基本的な用語から触れていく。
サブタイプ A, Bという2つの型があり、BがAのサブタイプである場合、Aが要求されているところはどこでも、Bを安全に使うことができる。
TypeScriptによる例を以下に示す。
 配列はオブジェクトのサブタイプ タプルは配列のサブタイプ 全ての値はanyのサブタイプ neverは全ての値のサブタイプ Animalを拡張するBirdというクラスがある場合、BirdはAnimalのサブタイプ  スーパータイプ A, Bという2つの型があり、BがAのスーパータイプである場合、Bが要求されているところ はどこでも、Aを安全に使うことができる。
TypeScriptによる例を以下に示す。
 オブジェクトは配列のスーパータイプ 配列はタプルのスーパータイプ anyは全ての値のスーパータイプ すべての値はneverのスーパータイプ AnimalはBirdのスーパータイプ   変性とは 型同士の関係性（型Aを指定したときに、そのサブタイプである型Bを当てはめられるかどうか）を判別するルールは、プログラム言語間で大きな相違点となっている。</description>
    </item>
    
    <item>
      <title>Map type &amp; Utility</title>
      <link>https://radish-miyazaki.github.io/4/</link>
      <pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://radish-miyazaki.github.io/4/</guid>
      <description>概要 前回の社内勉強会でMap型が話題に上がり、自分の復習のためにまとめる。
マップ型とは オブジェクトのキーの値とプロパティの型を指定することができる。 以下に例を示す。
type Weekday = &amp;#39;Mon&amp;#39; | &amp;#39;Tue&amp;#39; | &amp;#39;Wed&amp;#39; | &amp;#39;Thu&amp;#39; | &amp;#39;Fri&amp;#39; type Day = Weekday | &amp;#39;Sat&amp;#39; | &amp;#39;Sun&amp;#39; // 現在の曜日と次の曜日の組み合わせ let nextDay: {[K in Weekday]: Day} = { Mon: &amp;#39;Tue&amp;#39; } 上記は以下のようなエラーを示す。</description>
    </item>
    
    <item>
      <title>What&#39;s type declaration</title>
      <link>https://radish-miyazaki.github.io/1/</link>
      <pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://radish-miyazaki.github.io/1/</guid>
      <description>概要 .d.tsファイルや その内部に記述されている処理を今までフィーリングで扱っていたので学びなおした。
コードは一切出て来ないよ！
 型宣言とは ライブラリなどでよく見かける「.d.ts」という拡張子を持つファイル や スクリプトモードのファイル（.tsファイル） に存在している宣言。
これはJSDocアノテーションと同様、型付けされていないJavaScriptコードにTypeScriptの型を結びつけるための方法である。
Definitely Typedでは様々なパッケージの型宣言ファイルが公開されている。
 通常のTypeScriptの構文の違い 通常のTypeScriptの構文とは少し異なる箇所がある。
 型宣言は型だけを含むことができ、値を含むことはできない  関数・クラス・オブジェクト・変数の実装を持つことはできず、パラメータのデフォルト値を持つことも出来ない。
型宣言は、JavaScript内のどこかで定義される値が「存在する」ことは宣言できる  専用のキーワードdeclareを使う。
型宣言は、利用者から見えるものについての型だけを宣言する  エクスポートされない型や、関数の本体内のローカル変数の型のようなものは含まない。
 型宣言ファイルの用途 型宣言ファイルは以下の用途で使われている。
 どのような型が存在しているかTypeScriptに伝える  コンパイルされたTypeScriptを、ユーザがTypeScriptアプリケーションから使用する時に、 ユーザのTSCインスタンスは、生成されたJavaScriptファイルに対応する.</description>
    </item>
    
    <item>
      <title>Type alias vs Interface</title>
      <link>https://radish-miyazaki.github.io/2/</link>
      <pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://radish-miyazaki.github.io/2/</guid>
      <description>概要 社内で「TypeScriptの インタフェース と 型エイリアス の違いが上手くわからない！」 という声が上がっていたので、まとめておく。
同じところを認識したうえで、違う箇所を見たほうが頭に残るかなということで、両方見ていこう。 まずは、同じところから。
 同じところ 型エイリアスを使っている箇所はどこでも、インタフェースを使うことができる。
どちらの宣言も形状を定義しており、それらの形状は互いに割り当てが可能。
// 型エイリアス type Sushi = { calories: number salty: boolean tasty: boolean } // インタフェース interface Sushi { calories: number salty: boolean tasty: boolean } 更にどちらも型を組み合わせることもできる。まずは型エイリアスから見てみる。</description>
    </item>
    
    <item>
      <title>Ruby Null Object</title>
      <link>https://radish-miyazaki.github.io/3/</link>
      <pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://radish-miyazaki.github.io/3/</guid>
      <description>Null Objectとは Null Objectとは、「何もしないメソッド」を持つオブジェクトのこと。
クラスベースのオブジェクト指向言語（Java, C#など）だと時折見かける。
class Huga def huga &amp;#39;huga&amp;#39; end end class NullHuga def huga; end end class Hoge def process_huga(huga) # create_hugaはhuga or nullを返す設定 create_huga || NullHuga.new end end	Null Objectのメソッドを呼び出すと、エラーを出さずにメッセージをゴミ箱に捨ててくれる。</description>
    </item>
    
  </channel>
</rss>
